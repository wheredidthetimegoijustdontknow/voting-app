// app/actions/vote.test.ts
import { describe, it, expect, vi } from 'vitest';
import { submitVote } from './vote';

// Mock the external dependencies (Supabase, revalidatePath)
vi.mock('@/lib/supabase/server', () => ({
  createServerSupabaseClient: vi.fn().mockResolvedValue({
    // Mock the auth and from methods that the action calls
    auth: { getUser: vi.fn().mockResolvedValue({ data: { user: { id: 'test-user-id' } } }) },
    from: vi.fn(() => ({
      insert: vi.fn().mockResolvedValue({ data: null, error: null }),
    })),
  }),
}));
vi.mock('next/cache', () => ({
  revalidatePath: vi.fn(),
}));

describe('submitVote Server Action Zod Validation', () => {
  const validPollId = '123e4567-e89b-12d3-a456-426614174000';
  const validChoice = 'Option A';

  it('should pass with valid UUID and choice', async () => {
    const formData = new FormData();
    formData.append('poll_id', validPollId);
    formData.append('choice', validChoice);

    const result = await submitVote(formData);
    // Expect success and the database insertion to have been called
    expect(result.success).toBe(true);
    expect(result.error).toBeNull();
  });

  it('should fail if poll_id is an invalid UUID format', async () => {
    const formData = new FormData();
    formData.append('poll_id', 'not-a-valid-uuid'); // Invalid input
    formData.append('choice', validChoice);

    const result = await submitVote(formData);
    expect(result.success).toBe(false);
    // Check for the specific error message generated by Zod
    expect(result.error).toContain('Invalid Poll ID format');
  });

  it('should fail if choice is an empty string', async () => {
    const formData = new FormData();
    formData.append('poll_id', validPollId);
    formData.append('choice', ''); // Invalid input

    const result = await submitVote(formData);
    expect(result.success).toBe(false);
    expect(result.error).toContain('Choice cannot be empty');
  });
});